# -*- coding: utf-8 -*-
"""Pre-processamneto, cnn

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vEaOE7uUl1XMYVB4Nihgcsn-bRbxpkHl

####Trablho Redes Neurais convolucionais
### Pre-processamento
"""

from PIL import Image
import pandas as pd
import numpy as np
import cv2
import matplotlib.pyplot as plt
from glob import glob

image=Image.open("/download.jpeg")

image.show()

image

image.getpixel((2,4))

#importando imagem
imagem_bgr=cv2.imread("/download.jpeg")
imagem_bgr

#dimensões da imagem
imagem_bgr.shape

plt.imshow(imagem_bgr)

#converter a imagem para RGB
imagem=cv2.cvtColor(imagem_bgr,cv2.COLOR_BGR2RGB)

plt.imshow(imagem)

"""## Redimencionamento"""

#redimensionamento proporcional
print('Dimensões originais: ',imagem.shape)

scale_percent = 50 # percent of original size
width = int(imagem.shape[1] * scale_percent / 100)
height = int(imagem.shape[0] * scale_percent / 100)
dim = (width, height)

# resize image
resized = cv2.resize(imagem, dim, interpolation = cv2.INTER_AREA)

print('Nova dimensão: ',resized.shape)

plt.imshow(resized)
plt.title("Imagem redimencionada")
cv2.waitKey(0)
cv2.destroyAllWindows()

#redimencionamneto proporcional
#proporcional para ambos os lados
scale_percent = 50 # percent of original size
width = int(imagem.shape[1] * scale_percent / 100)
height = int(imagem.shape[0] * scale_percent / 100)
dim = (width, height)
# resize image
resized_prop = cv2.resize(imagem, dim, interpolation = cv2.INTER_AREA)

#Proporcional para mais
scale_percent2 = 200 # percent of original size
width2 = int(imagem.shape[1] * scale_percent2 / 100)
height2 = int(imagem.shape[0] * scale_percent2 / 100)
dim2 = (width2, height2)

bigger = cv2.resize(imagem, dim, interpolation = cv2.INTER_AREA)

Titles =["Original", "Metade", "Dobro"]
images =[imagem,resized_prop , bigger]
count = 3

for i in range(count):
    plt.subplot(2, 2, i + 1)
    plt.title(Titles[i])
    plt.imshow(images[i])

plt.show()

#mudando as dimenções
print('Dimensões Originais: ',imagem.shape)

#mantendo a altura original
resized_altura = cv2.resize(imagem, (180,imagem.shape[0]), interpolation = cv2.INTER_AREA)

#Mantendo a largura original
resized_largura = cv2.resize(imagem, (imagem.shape[1],120), interpolation = cv2.INTER_AREA)

#modificando a largura e altura
resized = cv2.resize(imagem, (160,92), interpolation = cv2.INTER_AREA)

print("Dimensões com a altura original: ",resized_altura)


Titles =["Original", "Altura original", "Largura Original","Valores pre-estabelecidos"]
images =[imagem,resized_altura,resized_largura,resized ]
count = 4

for i in range(count):
    plt.subplot(2, 2, i + 1)
    plt.title(Titles[i])
    plt.imshow(images[i])
    print("Dimensões com ",Titles[i],images[i].shape)

plt.show()

#mudando as dimenções
print('Dimensões Originais: ',imagem.shape)

##interpolação area
resized_area = cv2.resize(imagem, (160,92), interpolation = cv2.INTER_AREA)

#interpolação linear
resized_linear = cv2.resize(imagem, (160,92), interpolation = cv2.INTER_LINEAR)

#iterpolação pelo mais proximo
resized_near = cv2.resize(imagem, (160,92), interpolation = cv2.INTER_NEAREST)

#interpolação cubica
resized_cubic = cv2.resize(imagem, (160,92), interpolation = cv2.INTER_CUBIC)

#interpolação INTER_LANCZOS4
resized_lan = cv2.resize(imagem, (160,92), interpolation = cv2.INTER_LANCZOS4)
print("Dimensões com a altura original: ",resized_altura)


Titles =["Interpolação por area", "Interpolação linear","Interpolação nearest","Interpolação cubica",'Interpolaçã a Lanczos']
images =[resized_area,resized_linear,resized_near,resized_cubic, resized_lan]
count = 5


for i in range(count):
    plt.subplot(3, 3, i + 1)
    plt.title(Titles[i])
    plt.imshow(images[i])
    print("Dimensões com ",Titles[i],images[i].shape)

plt.show()

#definindo um tamanho espefifico para cada lado
print('Dimesnção original: ',imagem.shape)

width = 350
height = 450
dim = (width, height)

# resize image
resized_final = cv2.resize(imagem, dim, interpolation = cv2.INTER_AREA)

print('Novas dimensões: ',resized.shape)

plt.imshow(resized_final)
cv2.waitKey(0)
cv2.destroyAllWindows()

#redimencionamneto não proporcional outro explemplo, não esta no slide

# Redimensionamento não proporcional
half = cv2.resize(imagem, (0, 0), fx=0.1, fy=0.1)

# Redimensionamento proporcional
bigger = cv2.resize(imagem, (1050, 1610))

# Redimensionamento com interpolação mais próxima
stretch_near = cv2.resize(imagem, (780, 540), interpolation=cv2.INTER_NEAREST)

# Definição dos títulos das imagens
titles = ["Original", "Metade", "Maior", "Interpolation Nearest"]

# Lista com as imagens
images = [imagem, half, bigger, stretch_near]

# Contador de imagens
count = 4

# Loop para exibir as imagens
for i in range(count):
    # Cria um subplot 2x2
    plt.subplot(2, 2, i + 1)

    # Define o título do subplot
    plt.title(titles[i])

    # Exibe a imagem no subplot
    plt.imshow(images[i])

# Exibe as imagens na janela de plotagem
plt.show()

"""# Normalização"""

# Converter a imagem para escala de cinza
gray_image = cv2.cvtColor(imagem, cv2.COLOR_BGR2GRAY)

norm = np.zeros((800,800))
# Normalizar a imagem
normalized_image = cv2.normalize(imagem,norm , 0, 255, cv2.NORM_MINMAX)

# Exibir a imagem original e a imagem normalizada
plt.subplot(121),plt.imshow(imagem),plt.title("Imagem Original")
plt.subplot(122),plt.imshow(normalized_image),plt.title("Imagem Normalizada")
cv2.waitKey(0)
cv2.destroyAllWindows()

normalized_image

imagem

"""## Mudança para escala de cinza"""

imagem_gray=cv2.cvtColor(imagem,cv2.COLOR_RGB2GRAY)

print(imagem_gray)
print(imagem_gray.shape)

plt.imshow(imagem_gray)

plt.imshow(imagem_gray,cmap="gray")
plt.title("Imagem Original")

"""## Mudança para preto e branco

"""

ret, imagem_binaria=cv2.threshold(imagem_gray,127,1,cv2.THRESH_BINARY)
#todos os valores que são maiores do que 127 serão iguais a 1
#pode usar também o valor de 255 no lugar do 1 e usar a dunção com final _INV

imagem_binaria

plt.imshow(imagem_binaria,cmap="gray")

"""## Filtros

Equalização
"""

imagem_eq=cv2.equalizeHist(imagem_gray)
plt.imshow(imagem_eq,cmap="gray")
plt.title("Imagem equalizada")

"""Valorização das bordas"""

imagem_Canny=cv2.Canny(imagem_gray,100,200)     #parametros representam o limite de borda
plt.imshow(imagem_Canny,cmap="gray")

"""## Data argumentation"""

import random

"""Funçoes para diferentes tipos de transformação"""

def fill(img, h, w):
    img = cv2.resize(img, (h, w), cv2.INTER_CUBIC)
    return img

#variação no brilho
def brightness(img, low, high):
    value = random.uniform(low, high)
    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
    hsv = np.array(hsv, dtype = np.float64)
    hsv[:,:,1] = hsv[:,:,1]*value
    hsv[:,:,1][hsv[:,:,1]>255]  = 255
    hsv[:,:,2] = hsv[:,:,2]*value
    hsv[:,:,2][hsv[:,:,2]>255]  = 255
    hsv = np.array(hsv, dtype = np.uint8)
    img = cv2.cvtColor(hsv, cv2.COLOR_HSV2BGR)
    return img

def fill(img, h, w):
    img = cv2.resize(img, (h, w), cv2.INTER_CUBIC)
    return img

#variação no zoom
def zoom(img, value):
    if value > 1 or value < 0:
        print('Value for zoom should be less than 1 and greater than 0')
        return img
    value = random.uniform(value, 1)
    h, w = img.shape[:2]
    h_taken = int(value*h)
    w_taken = int(value*w)
    h_start = random.randint(0, h-h_taken)
    w_start = random.randint(0, w-w_taken)
    img = img[h_start:h_start+h_taken, w_start:w_start+w_taken, :]
    img = fill(img, h, w)
    return img
#mudança de canal
def channel_shift(img, value):
    value = int(random.uniform(-value, value))
    img = img + value
    img[:,:,:][img[:,:,:]>255]  = 255
    img[:,:,:][img[:,:,:]<0]  = 0
    img = img.astype(np.uint8)
    return img

#rotação horizontal
def horizontal_flip(img, flag):
    if flag:
        return cv2.flip(img, 1)
    else:
        return img

#rotação vertical
def vertical_flip(img, flag):
    if flag:
        return cv2.flip(img, 0)
    else:
        return img

#rotação
def rotation(img, angle):
    angle = int(random.uniform(-angle, angle))
    h, w = img.shape[:2]
    M = cv2.getRotationMatrix2D((int(w/2), int(h/2)), angle, 1)
    img = cv2.warpAffine(img, M, (w, h))
    return img

#Definindo parametros para as funçoes
# Valores para a função fill
h = 300
w = 400

# Valores para a função horizontal_shift
ratio_horizontal_shift = 0.5

# Valores para a função vertical_shift
ratio_vertical_shift = 0.1

# Valores para a função brightness
low_brightness = 0.8
high_brightness = 1.2

# Valores para a função zoom
zoom_value = 0.8

# Valores para a função channel_shift
channel_shift_value = 50

# Valor para o parâmetro flag nas funções de flip
flip_flag = True

# Valor para o parâmetro angle na função rotation
rotation_angle = 30

# Utilizando os valores sugeridos nas funções
filled_image = fill(imagem, h, w)
brightened_image = brightness(imagem, low_brightness, high_brightness)
zoomed_image = zoom(imagem, zoom_value)
channel_shifted_image = channel_shift(imagem, channel_shift_value)
horizontally_flipped_image = horizontal_flip(imagem, flip_flag)
vertically_flipped_image = vertical_flip(imagem, flip_flag)
rotated_image = rotation(imagem, rotation_angle)

"""variação do brilho"""

img=np.array(imagem)

def brightness(img, low, high):
    value = random.uniform(low, high)
    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
    hsv = np.array(hsv, dtype = np.float64)
    hsv[:,:,1] = hsv[:,:,1]*value
    hsv[:,:,1][hsv[:,:,1]>255]  = 255
    hsv[:,:,2] = hsv[:,:,2]*value
    hsv[:,:,2][hsv[:,:,2]>255]  = 255
    hsv = np.array(hsv, dtype = np.uint8)
    img = cv2.cvtColor(hsv, cv2.COLOR_HSV2BGR)
    return img
img_brilho = brightness(img, 15, 6)
plt.imshow( img_brilho)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""Variação de zoom"""

img=imagem
def fill(img, h, w):
    img = cv2.resize(img, (h, w), cv2.INTER_CUBIC)
    return img
def zoom(img, value):
    if value > 1 or value < 0:
        print('Value for zoom should be less than 1 and greater than 0')
        return img
    value = random.uniform(value, 1)
    h, w = img.shape[:2]
    h_taken = int(value*h)
    w_taken = int(value*w)
    h_start = random.randint(0, h-h_taken)
    w_start = random.randint(0, w-w_taken)
    img = img[h_start:h_start+h_taken, w_start:w_start+w_taken, :]
    img = fill(img, h, w)
    return img
img_zoom = zoom(img, 0.5)
plt.imshow( img_zoom)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""Mudança de canal"""

def channel_shift(img, value):
    value = int(random.uniform(-value, value))
    img = img + value
    img[:,:,:][img[:,:,:]>255]  = 255
    img[:,:,:][img[:,:,:]<0]  = 0
    img = img.astype(np.uint8)
    return img
img_canal = channel_shift(img, 50)
plt.imshow( img_canal)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""Rotação horizontal"""

img=imagem
def horizontal_flip(img, flag):
    if flag:
        return cv2.flip(img, 1)
    else:
        return img
img_rotH = horizontal_flip(img, True)
plt.imshow(img_rotH)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""Espelhar vertical"""

img=imagem
def vertical_flip(img, flag):
    if flag:
        return cv2.flip(img, 0)
    else:
        return img
img_rotV = vertical_flip(img, True)
plt.imshow(img_rotV)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""rotacionar"""

img=imagem
def rotation(img, angle):
    angle = int(random.uniform(-angle, angle))
    h, w = img.shape[:2]
    M = cv2.getRotationMatrix2D((int(w/2), int(h/2)), angle, 1)
    img = cv2.warpAffine(img, M, (w, h))
    return img
img_gir = rotation(img, 40)
plt.imshow(img_gir)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""## Ruido"""

#importar imagem com ruido
# Lendo a imagem que esta presente no mesmo diretorio
# do arquivo mediana.py
img_ruido = cv2.imread("/ruido.jpeg")

# Aplicando o filtro de mediana da biblioteca OpenCV
# que é importada como cv2 e atribuindo a variavel median
# utilizando uma mascara 5x5
mediana = cv2.medianBlur(img_ruido,(5))

# Codigo reponsavel por plotar a imagem original e
# o resultado lado a lado a nivel de comparacao
# mais informacoes sobre: https://matplotlib.org/index.html
plt.subplot(121),plt.imshow(img),plt.title('Original')
plt.xticks([]), plt.yticks([])
plt.subplot(122),plt.imshow(mediana),plt.title('Mediana')
plt.xticks([]), plt.yticks([])
plt.show()

import cv2
import matplotlib.pyplot as plt

# Importar imagem com ruído

# Aplicar o filtro de média da biblioteca OpenCV
media = cv2.blur(img_ruido, (5, 5))

# Plotar a imagem original e o resultado lado a lado
plt.subplot(121)
plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
plt.title('Original')
plt.xticks([])
plt.yticks([])

plt.subplot(122)
plt.imshow(cv2.cvtColor(media, cv2.COLOR_BGR2RGB))
plt.title('Filtro de Média')
plt.xticks([])
plt.yticks([])

plt.show()

plt.subplot(121)
plt.imshow(cv2.cvtColor(media, cv2.COLOR_BGR2RGB))
plt.title('Filtro de Média')
plt.xticks([])
plt.yticks([])

plt.subplot(122)
plt.imshow(cv2.cvtColor(mediana, cv2.COLOR_BGR2RGB))
plt.title('Filtro de Mediana')
plt.xticks([])
plt.yticks([])

plt.show()
plt.show()